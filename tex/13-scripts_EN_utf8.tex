\chapter{Using Unitex/GramLab with scripts}
\label{chap-scripts}\index{Scripting Unitex programs}

Unitex/GramLab can be used through scripts instead of the graphical interface.
The script launches external programs, which are documented in
Chapter~\ref{chap-external-programs}. The advantage of this possibility is that you may
access additional options in the programs, like option \verb$standoff$ of CasSys
(Section~\ref{section-standOff}), and even additional programs, such as
\verb$DumpOffsets$ (Section~\ref{section-DumpOffsets}). You may also, during preprocessing,
apply a cascade of several graphs in MERGE mode, whereas the graphical interface allows for only one.
Using scripts require more computer skills, and in particular more familiarity with the operating system.



\section{Translating into a script a processing launched via the graphical interface}
\label{section-console}

A simple way of writing a script that uses Unitex/GramLab is to launch the Unitex graphical interface,
to implement a preliminary version of the processing, and to translate your clicks into a sequence of commands.
To do that, you can generate a log file of the launched operations (Section~\ref{section-log-file}).
You can also take advantage of the fact that the Unitex graphical interface keeps track of these operations
and can display them in the
console ("Info > Console", Section \ref{section-console}, Fig. \ref{fig-console}). You select the steps
to be retained, you copy them into a text file and if needed you adapt them into an operational script.
In order to select the steps in the console, click on the corresponding cells in the `Log \#' column
(a shift-click and a ctrl-click have the usual effect in selecting several items).
You can insert into the script programs or options documented in
Chapter~\ref{chap-external-programs}, even if they are not available via the interface.

\bigskip
\noindent You can formalize a script in shell or batch form (Section~\ref{section-batch}),
or in the form of a Unitex-interpreted script (Section~\ref{section-unitex-scripts}).



\section{Shell or batch scripts}
\label{section-batch}

You can put a script in the form of a shell or batch script and execute it in the command-line
interface of the operating system. For example, the following commands open the
\verb$80jours$ French corpus, without the REPLACE- or MERGE-mode preprocessings, but with the default
dictionary, \verb$Dela_fr$, and launch a "Locate pattern" with graph \verb$pattern.fst2$
and generate a concordance:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
mkdir "U:\Unitex\French\Corpus\80jours_snt" 
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" Normalize
    "U:\Unitex\French/corpus.txt" "-rU:\Unitex\French\Norm.txt"
    "--output_offsets=U:\Unitex\French\Corpus\80jours_snt\normalize.out.offsets" -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" Tokenize "U:\Unitex\French\Corpus\80jours.snt" 
    "-aU:\Unitex\French\Alphabet.txt" -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" Dico "-tU:\Unitex\French\Corpus\80jours.snt" 
    "-aU:\Unitex\French\Alphabet.txt" "C:\Unitex-GramLab\French\Dela\Dela_fr.bin" -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" SortTxt "U:\Unitex\French\Corpus\80jours_snt\dlf" 
    "-lU:\Unitex\French\Corpus\80jours_snt\dlf.n" "-oU:\Unitex\French\Alphabet_sort.txt"
    -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" SortTxt "U:\Unitex\French\Corpus\80jours_snt\dlc" 
    "-lU:\Unitex\French\Corpus\80jours_snt\dlc.n" "-oU:\Unitex\French\Alphabet_sort.txt"
    -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" SortTxt "U:\Unitex\French\Corpus\80jours_snt\err" 
    "-lU:\Unitex\French\Corpus\80jours_snt\err.n" "-oU:\Unitex\French\Alphabet_sort.txt"
    -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" SortTxt
    "U:\Unitex\French\Corpus\80jours_snt\tags_err"
    "-lU:\Unitex\French\Corpus\80jours_snt\tags_err.n" "-oU:\Unitex\French\Alphabet_sort.txt"
    -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" Locate "-tU:\Unitex\French\Corpus\80jours.snt" 
    "U:\Unitex\French\Graphs\pattern.fst2" "-aU:\Unitex\French\Alphabet.txt" -L -M --all -b -Y
    --stack_max=1000 --max_matches_per_subgraph=200 --max_matches_at_token_pos=400 
    --max_errors=50 -qutf8-no-bom
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" Concord
    "U:\Unitex\French\Corpus\80jours_snt\concord.ind" "-fCourier new" -s10 -l40 -r55 --html 
    "-aU:\Unitex\French\Alphabet_sort.txt" --CL -qutf8-no-bom
\end{Verbatim}

\noindent For details of the scripts or any comments in it, you have to respect the operating system's
 conventions.



\section{Unitex/GramLab-interpreted scripts}
\label{section-unitex-scripts}\index{Package!\verbc{linguistic}}

Unitex/GramLab has also a scripting language, with several advantages over shell or batch
scripts.
\begin{itemize}
    \item Execution is quicker than with an equivalent shell or batch script, since the interpreter manages a
virtual file system.
    \hyphenation{pac-kage}
    \item The script and all the resources it requires are encapsulated in a `linguistic package'
    that you can deploy in another environment later. This way, the development of the script and its
    use in a processing chain are completely independent:
\begin{itemize}
    \item you can deploy the package without any knowledge of Unitex or of the linguistic processing
    implemented in the script,
    \item the development environment and the deployment environment are not necessarily
    in the same operating system,
    \item the processing does not modify any data in the deployment environment, since it is applied
    to a copy of the corpus and uses a copy of the resources included in the package. Only the files
explicitly specified as being the output of the processing are copied into the deployment environment in the end 
of the processing.
\end{itemize}
\end{itemize}

\noindent The scripting language consists of the Unitex external programs, including
a few programs implemented specially for the script interpreter 
(Section~\ref{section-script-for-runscript}). There can be comment lines, beginning with 
the  \# character. The commands of the operating system are not recognised.

\bigskip\index{External programs!\verbc{RunScript}}\index{External programs!\verbc{BatchRunScript}}
\noindent The Unitex/GramLab script interpreter exists in two variants named \verb$RunScript$ and
\verb$BatchRunScript$. \verb$RunScript$ launches a script on a corpus contained in one or several files.
\verb$BatchRunScript$ processes a corpus consisting of all the files in a directory,
by launching the script once on each file, and it generates a separate output file for each.




\subsection{Implementing a linguistic package}
\label{section-packaga-creation}

A Unitex/GramLab linguistic package includes a script and all the language resources it uses,
except the input corpus. The package is organised in the form of a directory tree, and 
compressed in Zip format.

\bigskip
\noindent The tree root is a directory \verb$<ling_pkg_name>$ with two subdirectories
named \verb$script$ and \verb$resource$. The script must be placed in
 \verb$<ling_pkg_name>/script$ and all the required language resources in
\verb$<ling_pkg_name>/resource$. You can mimic in \verb$resource$ the organization of a
personal Unitex workspace, with a subdirectory for each language processed by the script
(for example \verb$French$), then, in each language directory, alphabet files
\verb$Alphabet.txt$ and \verb$Alphabet_sort.txt$, normalization file \verb$Norm.txt$ etc., and
subdirectories \verb$Dela$, \verb$Graphs$ etc.\ and, in turn, the respective data in them.
With this organization, it is easier to write the script by adapting a script from the console.

\bigskip
\noindent If you want the script to access the date of the package, create an empty text file in 
\verb$<ling_pkg_name>/resource$ and name it \verb$VERSION_AAAAMMJJ$
(without extension).

\bigskip
\noindent When the tree is finished, compress it in Zip format.

\bigskip
\noindent For example, in order to encapsulate the processing of Section~\ref{section-batch}
in a package named \verb$pkg.zip$, you have to copy into a \verb$pkg$ directory:
\begin{itemize}
\item in subdirectory \verb$resource$:
\begin{itemize}
\item the alphabet files, \verb$Alphabet.txt$ and \verb$Alphabet_sort.txt$, and the normalization
file \verb$Norm.txt$ in \verb$French$;
\item the dictionary files \verb$Dela_fr.bin$ and \verb$Dela_fr.inf$ in \verb$French/Dela$;
\item the graph \verb$pattern.fst2$ in \verb$French/Graphs$ (optionally, you can also copy the file
\verb$pattern.grf$ there);
\end{itemize}
\item in subdirectory \verb$script$, the script file.
\end{itemize}



\subsection{Lancement avec RunScript}
\label{section-runscript}\index{External programs!\verbc{RunScript}}
\index{External programs!\verbc{UnitexToolLogger}}
\verb$RunScript$ permet de lancer un script sur un corpus contenu dans un ou plusieurs fichiers.
Pour cela, on invoque le programme \verb$UnitexToolLogger$ (section~\ref{section-UnitexToolLogger})
en respectant la syntaxe suivante:
\index{External programs!\verbc{SelectOutput}}
\index{External programs!\verbc{InstallLingResourcePackage}}

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
UnitexToolLogger [ { SelectOutput <args1> } ] { InstallLingResourcePackage <args2> } { RunScript
    <args3> } { InstallLingResourcePackage <args4> }
\end{Verbatim}

\noindent Chaque paire d'accolades délimite l'invocation d'une commande Unitex avec ses arguments.

\begin{enumerate}
\item L'étape \verb$SelectOutput$ est facultative mais recommandée. En l'incluant sous la forme
suivante:\\
\verb$     { SelectOutput --output=off }$\\
on masque les sorties de mise au point de chaque commande ultérieure, qui sont encombrantes
dans le cas d'une exécution massive.
\item L'étape suivante, \verb$InstallLingResourcePackage$, installe le contenu du package linguistique
dans le système de fichiers virtuel.
\item L'étape \verb$Rusncript$ lance le script. Elle doit définir dans  \verb$INPUT_FILE_1$ et
éventuellement \verb$INPUT_FILE_2$, etc., le nom du ou des fichiers contenant le corpus d'entrée; dans
\verb$OUTPUT_FILE_1$, \verb$OUTPUT_FILE_2$, etc., le nom du ou des fichiers résultats;
dans \verb$PACKAGE_DIR$ le nom du répertoire racine du package linguistique dans le système
de fichiers virtuel ; dans \verb$CORPUS_WORK_DIR$ le nom du répertoire qui contiendra les fichiers
créés pendant l'exécution du script.
\item La dernière étape écrit le ou les fichiers résultats, puis met fin au système de fichiers virtuel.
\end{enumerate}

\noindent Par exemple, la commande suivante utilise le package linguistique \verb$pkg.zip$ de la
section~\ref{section-packaga-creation} et lance
le script \verb$uniscript$ contenu dans ce package, avec comme corpus d'entrée \verb$80jours.txt$
et comme fichier de sortie \verb$80jours_result.html$.

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" { SelectOutput --output=off } {
    InstallLingResourcePackage -p U:\Scripts\pkg.zip -x "$:UnitexPkgResource" -v } { RunScript -v
    -a INPUT_FILE_1=U:\Unitex\French\Corpus\80jours.txt 
    -a "CORPUS_WORK_DIR=$:UnitexPkgWork" -a "PACKAGE_DIR=$:UnitexPkgResource"
    -a OUTPUT_FILE_1=U:\Unitex\French\Corpus\80jours_result.html 
    "$:UnitexPkgResource\script\uniscript" } { InstallLingResourcePackage -p U:\Scripts\pkg.zip 
    -x "$:UnitexPkgResource" -u -v }
\end{Verbatim}



\subsection{Lancement avec BatchRunScript}
\label{launch-script}\index{External programs!\verbc{BatchRunScript}}

\verb$BatchRunScript$ permet de traiter un corpus constitué par tous les fichiers d'un répertoire.
Il lance le script une fois sur chaque fichier, produisant à chaque fois un fichier résultat séparé.
On peut ainsi réaliser des traitements massifs efficacement, même sur des documents nombreux
contenus dans des fichiers séparés. Le résultat est stocké dans un répertoire de sortie, dans des
fichiers portant les mêmes noms que les fichiers d'entrée, suffixés par \verb$.result.txt$.
\verb$BatchRunScript$ fonctionne en multithread et lance plusieurs exécutions en parallèle: ainsi
tous les cœurs de la machine de traitement peuvent fonctionner en même temps et traiter
l’ensemble des fichiers plus vite.

\bigskip
\noindent Pour déployer un script avec \verb$BatchRunScript$, on respecte la syntaxe suivante:

\begin{verbatim}
UnitexToolLogger { BatchRunScript <args> }
\end{verbatim}

\noindent Les arguments doivent définir le nom du répertoire contenant le corpus d'entrée
dans le système de fichiers virtuel, le nom du répertoire de sortie, le nombre de threads, le nom
du package linguistique et le nom du script. Par exemple, la commande suivante traite tous les
fichiers du répertoire \verb$input_folder$, stocke les résultats dans \verb$output_folder$
et fonctionne sur quatre threads:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
"C:\Unitex-GramLab\App\UnitexToolLogger.exe" { BatchRunScript -i .\input_folder -o .\output_folder 
    -t 4 .\pkg -v -p -m -s script/uniscript }
\end{Verbatim}

\noindent Les options \verb$-v$, \verb$-m$ et \verb$-p$ permettent de contrôler quelles 
informations sont émises sur la console pendant les traitements. Ainsi, en utilisant \verb$-v -p$,
on affiche le maximum de sorties, ce qui est utile pendant la mise au point. Avec \verb$-m$
et plus encore \verb$-f$, on affiche le minimum de messages.

\bigskip
\noindent Avec \verb$BatchRunScript$, une exécution du script sur un fichier ne peut pas
renvoyer plusieurs fichiers, contrairement à \verb$RunScript$\footnote{Il est possible de
contourner cette limitation avec les outils \texttt{PackFile}  et \texttt{UnpackFile}, en
regroupant plusieurs fichiers résultats en un seul fichier de type Zip.}.



\subsection{Mise au point d'un script pour RunScript}
\label{section-script-for-runscript}
Pour écrire un script dans un package linguistique, il est recommandé d'adapter un script issu
de la console, comme celui de la section~\ref{section-batch}.

\begin{itemize}     \hyphenation{exem-ple}
\item Dans chaque ligne du script issu de la console, supprimer la mention du programme
\verb$UnitexToolLogger$ en début de ligne, c'est-à-dire dans notre exemple
\verb$"C:\Unitex-GramLab\App\UnitexToolLogger.exe"$.
\item Dans les noms des ressources, remplacer le chemin du répertoire de travail par
\verb${PACKAGE_DIR}/resource$. Dans notre exemple, le fichier de normalisation pour le français
devient \verb${PACKAGE_DIR}/resource/French/Norm.txt$.
\item Dans les noms des fichiers créés par le script, remplacer le chemin complet par
\verb${CURRENT_WORK_DIR}$. Dans notre exemple, le nom du fichier \verb$80jours.snt$ devient
\verb${CURRENT_WORK_DIR}/80jours.snt$.
\end{itemize}

\noindent La valeur de \verb$PACKAGEDIR$ est déjà définie quand le script commence à s'exécuter,
mais pour \verb$CURRENT_WORK_DIR$ il faut commencer le script par quelques lignes qui donnent un
nom à ce répertoire, le créent, y copient le corpus d'entrée et font quelques autres préparatifs:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
CURRENT_WORK_DIR = {CORPUS_WORK_DIR}/{UNIQUE_VALUE}
\end{Verbatim}

\noindent Cette ligne donne un nom à \verb$CURRENT_WORK_DIR$. La valeur de
\verb$CORPUS_WORK_DIR$ est déjà définie quand le script commence à s'exécuter. La variable
\verb$UNIQUE_VALUE$ contient une chaine de caractères définie par \verb$RunScript$ ou par
\verb$BatchRunScript$, avec la garantie que la chaine est différente pour chaque exécution de
\verb$RunScript$ ou pour chaque thread de \verb$BatchRunScript$ s’exécutant simultanément. Cela
permet d'éviter toute collision entre fichiers temporaires pendant des travaux simultanés. Ensuite,
comme la commande \verb$mkdir$ n’est pas utilisable dans un script interprété par Unitex/GramLab, on
utilise \verb$DuplicateFile -p$ pour créer le répertoire:
\index{External programs!\verbc{DuplicateFile}}

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
DuplicateFile -p {CURRENT_WORK_DIR}
\end{Verbatim}

\noindent On y copie le corpus d’entrée:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
DuplicateFile -i {INPUT_FILE_1} {CURRENT_WORK_DIR}/corpus.txt
\end{Verbatim}

\noindent Dans notre exemple, la première commande du script issu de la console utilisait la commande
\verb$mkdir$ pour créer le sous-répertoire \verb$corpus_snt$. On doit donc la remplacer par
\verb$DuplicateFile$:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
DuplicateFile --make-dir {CURRENT_WORK_DIR}/corpus_snt
\end{Verbatim}

\noindent Les deux lignes suivantes écrivent dans des fichiers des informations sur la version d'Unitex
utilisée:\index{External programs!\verbc{VersionInfo}}


\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
VersionInfo -n -o {CURRENT_WORK_DIR}/newrevision.txt
VersionInfo -s -o {CURRENT_WORK_DIR}/semver.txt
\end{Verbatim}

\noindent La ligne suivante sauvegarde la date de version du package linguistique, à condition d'avoir
inclus dans le package un fichier \verb$VERSION_AAAAMMJJ$ (voir section \ref{section-packaga-creation}):

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
VersionInfo -B -o {CURRENT_WORK_DIR}/builddate.txt
\end{Verbatim}

\noindent Le corps du script peut apparaitre ensuite:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
Normalize "{CURRENT_WORK_DIR}/corpus.txt" "-r{PACKAGE_DIR}/resource/French/Norm.txt" 
    "--output_offsets={CURRENT_WORK_DIR}/corpus_snt/normalize.out.offsets" -qutf8-no-bom
Tokenize "{CURRENT_WORK_DIR}/corpus.snt" "-a{PACKAGE_DIR}/resource/French/Alphabet.txt"
    -qutf8-no-bom
Dico "-t{CURRENT_WORK_DIR}/corpus.snt" "-a{PACKAGE_DIR}/resource/French/Alphabet.txt" 
    "{PACKAGE_DIR}/resource/French/Dela/Dela_fr.bin" -qutf8-no-bom
SortTxt "{CURRENT_WORK_DIR}/corpus_snt/dlf" "-l{CURRENT_WORK_DIR}/corpus_snt/dlf.n" 
    "-o{PACKAGE_DIR}/resource/French/Alphabet_sort.txt" -qutf8-no-bom
SortTxt "{CURRENT_WORK_DIR}/corpus_snt/dlc" "-l{CURRENT_WORK_DIR}/corpus_snt/dlc.n" 
    "-o{PACKAGE_DIR}/resource/French/Alphabet_sort.txt" -qutf8-no-bom
SortTxt "{CURRENT_WORK_DIR}/corpus_snt/err" "-l{CURRENT_WORK_DIR}/corpus_snt/err.n" 
    "-o{PACKAGE_DIR}/resource/French/Alphabet_sort.txt" -qutf8-no-bom
SortTxt "{CURRENT_WORK_DIR}/corpus_snt/tags_err"
    "-l{CURRENT_WORK_DIR}/corpus_snt/tags_err.n" 
    "-o{PACKAGE_DIR}/resource/French/Alphabet_sort.txt" -qutf8-no-bom
Locate "-t{CURRENT_WORK_DIR}/corpus.snt"
    "{PACKAGE_DIR}/resource/French/Graphs/test.fst2" 
    "-a{PACKAGE_DIR}/resource/French/Alphabet.txt" -L -M --all -b -Y --stack_max=1000
    --max_matches_per_subgraph=200 --max_matches_at_token_pos=400 --max_errors=50
    -qutf8-no-bom
Concord "{CURRENT_WORK_DIR}/corpus_snt/concord.ind" "-fCourier new" -s10 -l40 -r55 --html 
    "-a{PACKAGE_DIR}/resource/French/Alphabet_sort.txt" --CL -qutf8-no-bom
\end{Verbatim}

\noindent La fin du script doit indiquer le nom du ou des fichiers résultats et libérer la mémoire:
\index{External programs!\verbc{DuplicateFile}}

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
DuplicateFile -i {CURRENT_WORK_DIR}/corpus_snt/concord.html {OUTPUT_FILE_1}
DuplicateFile --recursive-delete {CURRENT_WORK_DIR}
\end{Verbatim}

\noindent On peut lancer le script avec la commande de la section~\ref{launch-script}. Le résultat
obtenu est juste un fichier de concordance \verb$80jours_result.html$, placé à côté de
\verb$80jours.txt$.

\bigskip
\noindent Si on ajoute au script, en avant-dernière position, la ligne:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
DuplicateFile -i {CURRENT_WORK_DIR}/corpus_snt/dlf {OUTPUT_FILE_2}
\end{Verbatim}

\noindent on doit aussi ajouter à la commande de lancement l'option:

\begin{Verbatim}[fontsize=\small,fontfamily=helvetica]
-a OUTPUT_FILE_2=U:\Unitex\French\Corpus\80jours_result.dic
\end{Verbatim}

\noindent On obtient alors comme résultat un fichier dictionnaire \verb$80jours_result.dic$, placé à côté
des deux autres.
